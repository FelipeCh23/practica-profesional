import numpy as np
import shapely as shp
import json

# ===========================================================================
# SECCI√ìN 1: FUNCIONES GEOM√âTRICAS AUXILIARES (Adaptadas de appRing.py)
# ===========================================================================

def get_angle(line_1: shp.LineString, line_2: shp.LineString) -> float:
    """Calcula el √°ngulo en grados entre dos l√≠neas para el rango [-180, 180]."""
    u = np.array(line_1.coords[1]) - np.array(line_1.coords[0])
    v = np.array(line_2.coords[1]) - np.array(line_2.coords[0])
    num = u[0]*v[1] - u[1]*v[0]
    den = u[0]*v[0] + u[1]*v[1]
    angle = np.degrees(np.arctan2(num, den))
    return angle

def sort_points(geometry, pivot: shp.Point):
    """Ordena los puntos de una geometr√≠a desde el m√°s cercano al m√°s lejano al pivote."""
    points = list(shp.extract_unique_points(geometry).geoms)
    points.sort(key=lambda point: point.distance(pivot))
    return points

# ===========================================================================
# SECCI√ìN 2: L√ìGICA DE GENERACI√ìN DE DISE√ëOS (Adaptada de HolesDesigner)
# ===========================================================================

def find_endpoints(stope: shp.Polygon, drift: shp.Polygon, pivot: shp.Point, line: shp.LineString, max_length: float):
    """Halla el collar (inicio) y el fondo (fin) de una perforaci√≥n."""
    collar = line.intersection(drift.exterior)
    if collar.is_empty:
        return None, None # La l√≠nea de perforaci√≥n no pasa por la galer√≠a

    max_toe = line.interpolate(max_length + collar.distance(pivot))
    hole_line = shp.LineString([pivot, max_toe])
    
    # Usamos buffer para evitar errores de precisi√≥n si el pivote est√° justo en el borde
    if pivot.intersects(stope.exterior):
        stope = stope.buffer(1e-6)

    intersections = hole_line.intersection(stope.exterior)
    if intersections.is_empty:
        return collar, max_toe # El tiro no alcanza el caser√≥n, se usa la longitud m√°xima

    if isinstance(intersections, shp.Point):
        toe = intersections
    else: # M√∫ltiples intersecciones, elegimos la m√°s lejana
        toe = sort_points(intersections, pivot)[-1]

    return collar, toe

def angular_method(stope_geom, drift_geom, pivot_geom, params):
    """
    Genera un abanico de perforaci√≥n usando espaciamiento angular constante.
    Esta es una de las l√≥gicas clave de `appRing.py`.
    """
    collars, toes = [], []
    stope = shp.Polygon(stope_geom)
    drift = shp.Polygon(drift_geom)
    pivot = shp.Point(pivot_geom)

    angle_range = abs(params['max_angle'] - params['min_angle'])
    
    if params['holes_number'] > 1:
        angle_step = angle_range / (params['holes_number'] - 1)
    else:
        angle_step = 0

    current_angle = params['min_angle']

    for i in range(params['holes_number']):
        # Se crea una l√≠nea de referencia muy larga y se rota al √°ngulo deseado
        ref_line = shp.LineString([pivot, (pivot.x, pivot.y + 10000)])
        rotated_line = shp.affinity.rotate(ref_line, angle=current_angle, origin=pivot)

        # Se encuentran los puntos de inicio y fin del tiro
        collar, toe = find_endpoints(stope, drift, pivot, rotated_line, params['max_length'])

        if collar and toe:
             # Se podr√≠a a√±adir aqu√≠ una validaci√≥n de longitud m√≠nima como en `valid_hole`
            collars.append(list(collar.coords)[0])
            toes.append(list(toe.coords)[0])

        current_angle += angle_step

    return {"geometry": [collars, toes]}

# ===========================================================================
# SECCI√ìN 3: L√ìGICA DE C√ÅLCULO DE COSTOS (Adaptada de nuestro 'Budget Blast')
# ===========================================================================

def calculate_total_cost(design: dict, unit_costs: dict) -> float:
    """Calcula el costo total de un dise√±o completo (perforaci√≥n, explosivos, etc.)."""
    
    # 1. Costo de Perforaci√≥n
    total_drill_length = 0
    if 'holes' in design and 'geometry' in design['holes']:
        collars = np.array(design['holes']['geometry'][0])
        toes = np.array(design['holes']['geometry'][1])
        total_drill_length = np.sum(np.linalg.norm(toes - collars, axis=1))
    
    cost_drilling = total_drill_length * unit_costs['perforacion_por_metro']

    # 2. Costo de Explosivos (simplificado por ahora)
    total_charge_mass = 0
    if 'charges' in design:
        # Aqu√≠ ir√≠a la l√≥gica para calcular la masa total de explosivo
        # ql = (7.854e-4) * density * (diameter ** 2)
        # total_charge_mass = total_charge_length * ql
        pass # Por ahora lo dejamos en 0
        
    cost_explosives = total_charge_mass * unit_costs['explosivo_por_kg']
    
    # 3. Costo de Detonadores (simplificado)
    num_detonators = 0
    if 'blasts' in design:
        num_detonators = design['blasts'].get('detonator', {}).get('cantidad', 0)
        
    cost_detonators = num_detonators * unit_costs['detonador_por_unidad']

    return cost_drilling + cost_explosives + cost_detonators

# ===========================================================================
# SECCI√ìN 4: EL OPTIMIZADOR (Implementaci√≥n del Diagrama de Flujo)
# ===========================================================================

def optimize_fan_design(stope_geom, drift_geom, pivot_geom, budget_params):
    """
    Bucle principal que itera para encontrar el mejor dise√±o de abanico.
    """
    valid_designs = []
    
    s_min = budget_params['s_min']
    s_max = budget_params['s_max']
    
    print(f"üöÄ Iniciando optimizaci√≥n. Probando espaciamientos de {s_min} a {s_max} m...")

    # Bucle principal: iterar sobre diferentes espaciamientos (S)
    # Por ahora, simulamos el cambio de S cambiando el n√∫mero de tiros.
    for num_tiros in range(int(s_min), int(s_max) + 1):
        
        print(f"\n--- Probando con {num_tiros} tiros ---")
        
        # 1. CONSTRUIR EL DISE√ëO
        # Usamos el m√©todo angular como ejemplo. `s` aqu√≠ se interpreta como el n√∫mero de tiros.
        design_params = {
            'min_angle': -45.0,
            'max_angle': 45.0,
            'max_length': 20.0, # Longitud m√°xima de perforaci√≥n en metros
            'holes_number': num_tiros
        }
        
        # Generamos la geometr√≠a de la perforaci√≥n
        holes_design = angular_method(stope_geom, drift_geom, pivot_geom, design_params)
        
        # Ensamblamos un objeto de dise√±o completo (simplificado)
        current_design = {
            "holes": holes_design,
            # Aqu√≠ se generar√≠an 'charges' y 'blasts'
            "blasts": {"detonator": {"cantidad": num_tiros}}
        }

        # 2. CALCULAR EL COSTO
        total_cost = calculate_total_cost(current_design, budget_params['unit_costs'])
        print(f"Costo del dise√±o generado: ${total_cost:,.2f}")

        # 3. VERIFICAR PRESUPUESTO
        if total_cost <= budget_params['presupuesto_maximo']:
            print(f"‚úÖ Dise√±o V√ÅLIDO (dentro del presupuesto)")
            # Guardamos el dise√±o y su costo
            valid_designs.append({'design': current_design, 'cost': total_cost})
        else:
            print(f"‚ùå Dise√±o INV√ÅLIDO (excede el presupuesto)")

    # 4. SELECCIONAR EL MEJOR DISE√ëO
    if not valid_designs:
        print("\nNo se encontr√≥ ning√∫n dise√±o que cumpliera con el presupuesto.")
        return None
    
    # Criterio: el m√°s barato de los v√°lidos
    best_design = min(valid_designs, key=lambda x: x['cost'])
    
    print("\n=========================================")
    print("üèÜ Optimizaci√≥n Finalizada üèÜ")
    print(f"Se encontraron {len(valid_designs)} dise√±os v√°lidos.")
    print(f"El mejor dise√±o tiene {len(best_design['design']['holes']['geometry'][0])} tiros y un costo de ${best_design['cost']:,.2f}")
    print("=========================================")
    
    return best_design


# ===========================================================================
# SECCI√ìN 5: EJECUCI√ìN DEL SCRIPT
# ===========================================================================

if __name__ == '__main__':
    # Entradas del problema (similares al JSON que definiste)
    stope_polygon = [[0,0], [20,0], [20,30], [0,30]]
    drift_polygon = [[8,10], [12,10], [12,14], [8,14]]
    pivot_point = [10, 12]

    # Par√°metros del presupuesto y optimizaci√≥n
    budget_parameters = {
        "presupuesto_maximo": 10000.0,
        "s_min": 5,  # Para este ejemplo, interpretamos S como "n√∫mero de tiros" m√≠nimo
        "s_max": 15, # y m√°ximo.
        "unit_costs": {
            "perforacion_por_metro": 25.5,
            "explosivo_por_kg": 0, # A√∫n no implementado
            "detonador_por_unidad": 15.0
        }
    }
    
    # Ejecutar el optimizador
    resultado_optimo = optimize_fan_design(stope_polygon, drift_polygon, pivot_point, budget_parameters)

    # (Opcional) Guardar el mejor dise√±o en un archivo JSON
    if resultado_optimo:
        with open('mejor_dise√±o.json', 'w') as f:
            json.dump(resultado_optimo['design'], f, indent=4)
        print("\nEl mejor dise√±o se ha guardado en 'mejor_dise√±o.json'")